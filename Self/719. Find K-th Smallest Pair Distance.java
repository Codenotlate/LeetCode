// 2024.10.16
// It's a BS question, since we know the number is in range of [min(a[i]-a[i-1]), a[last]-a[0]] from the sorted array 
// The tricky part is to know what we are trying to find through BS here. We are actually trying to find the first element that has a smallerOrEqualTo count  == k. This guarantees the number we get from the range is actually a diff generated by the array. Cause we to make smallerOrEqualTo number increased from x (say for num1) to x+1 (say for num2), we must have included one pair diff inside range (num1, num2]. And yet we are trying to find the first one has count == x+1, and that must comes from the case when that specific pair diff is first included into range (num1, num2], i.e. (num1, specific pair diff].
// for finding first one satisfy some condition, we can use the template while(left < right)... if(condition satisfy) {right = mid;} else {left = mid + 1}.
// then we determine the condition here is count the smallerOrEqualTo number, we can use sliding window here, start with left = 0, right=1. And check diff = nums[right] - nums[left], if diff <= k, right++, count += right-left; elseif diff > k, left++.
// time: sort O(nlogn) + BS O(nlog(maxDiff-minDiff))
// space: sort space - In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of O(logn)

class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        int maxDiff = nums[nums.length-1]-nums[0];
        int minDiff = maxDiff;
        for (int i = 1; i < nums.length; i++) {
            minDiff = Math.min(minDiff, nums[i]-nums[i-1]);
        }
        int left = minDiff;
        int right = maxDiff;
        while (left < right) {
            int mid = left + (right-left) / 2;
            if (countSmallerOrEqualto(mid, nums) < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    private int countSmallerOrEqualto(int target, int[] nums) {
        int left = 0;
        int right = 1;
        int count = 0;
        while (right < nums.length) {
            int diff = nums[right]-nums[left];
            if (diff <= target) {
                count += right - left; // add all pairs ending with current left inside the window
                right++;
            } else {
                left++;
                right = Math.max(right, left+1); // this line is essential
            }
        }
        return count;
    }
}






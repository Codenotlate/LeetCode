/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
/**
method1: divide and conquer
1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n.
*/
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return genTreeHelper(1, n);
    }

    private List<TreeNode> genTreeHelper(int start, int end) {
    	List<TreeNode> res = new ArrayList<>();
    	// special case
    	if (start > end) {
    		res.add(null);
    		return res;
    	}

    	for (int i = start; i <= end; i++) {
    		List<TreeNode> smallTreeList = genTreeHelper(start, i - 1);
    		List<TreeNode> largeTreeList = genTreeHelper(i + 1, end);
    		for (TreeNode smallTree: smallTreeList) {
    			for (TreeNode largeTree: largeTreeList) {
    				TreeNode root = new TreeNode(i);
    				root.left = smallTree;
    				root.right = largeTree;
    				res.add(root);
    			}
    		}
    	}

    	return res;
    }
}



// method2； DP

/**
Using DP causes two problems:
1）It consumes lots of space, so possible running out of heap space for large n
2) Using DP means you are reusing Subtree[start, end] solution. Which means if two unique BST both contains Subtree[3, 5], you are using the same saved subtree in two different BST. It is not a completely deep copy.
(We must be careful to clarify it with our interviewer if they want separate lists or can they have common nodes.)
*/
// following is a DP way using deep copy. 
// The deep copy build the tree having the same structure as tree root in n, but with each value in the node increased to node.val + offset
// e.g. [1,2,3] should have all the BSTs the same structure as the result for [4,5,6], the only difference is add value 3 to each node in [1,2,3]'s result BST tree.


class Solution {
    public List<TreeNode> generateTrees(int n) {
        // use result to store the dp result for subproblems
        // result[i] represent the TreeNode list generated by node from 1 to i.
        List<TreeNode>[] result = new List[n + 1];
        result[0] = new ArrayList<TreeNode>();
        if (n == 0) {return result[0];}

        // start with building result[0]
        result[0].add(null);
        for (int len = 1; len <= n; len++) {
        	result[len] = new ArrayList<TreeNode>();
        	// plan to use j+1 as root val, and tree in result[j] as left subtree, tree in result[len - 1 - j] with node value increased by offset as right subtree.
        	for (int j = 0; j < len; j++) {
        		for (TreeNode left: result[j]) {
        			for (TreeNode right: result[len - 1 - j]) {
        				TreeNode root = new TreeNode(j + 1);
        				root.left = left;
        				// since the original right is starting from node 1, whereas the real right subtree should start from node j + 2;
        				root.right = copyAddingVal(right, j + 1);
        				result[len].add(root);
        			}
        		}
        	}
        }
        return result[n];
    }


    private TreeNode copyAddingVal(TreeNode root, int val) {
    	if (root == null) {return null;}
    	TreeNode newRoot = new TreeNode(root.val + val);
    	newRoot.left = copyAddingVal(root.left, val);
    	newRoot.right = copyAddingVal(root.right, val);
    	return newRoot;
    }
}


// Phase3 self
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return treeHelper(1, n);
    }
    
    
    private List<TreeNode> treeHelper(int start, int end) {
        List<TreeNode> res = new LinkedList<>();
        if (start > end) {res.add(null); return res;}
        if (start == end) {res.add(new TreeNode(start)); return res;}
        for (int i = start; i <= end; i++) {
            List<TreeNode> leftTrees = treeHelper(start, i-1);
            List<TreeNode> rightTrees = treeHelper(i+1, end);
            for (TreeNode left: leftTrees){
                for (TreeNode right: rightTrees) {
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                }              
            }
        }
        return res;
    }
}












